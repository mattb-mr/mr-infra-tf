00:00:00:00 - 00:00:22:15
Unknown
Are you tired of manually running Terraform? Apply on your laptop, waiting endlessly for resources to create or destroy before you can just shut down for the day? Today I'll show you how to run Terraform with GitHub actions. We'll set this up step by step, then cover the gotchas that surface at scale. Why teams switch to dedicated Terraform automation platforms like SpaceX, Lyft.

00:00:22:17 - 00:00:44:14
Unknown
Setting the stage. It can be good to experiment with custom IAC workflows and GitHub actions. Knowing the nuts and bolts of how IAC works will be helpful when handling these processes at scale. First, we need a GitHub repo for all Terraform code. In our example, we have a simple main TF that spins up an AWS, EC2 instance. We also configure a remote state for Terraform.

00:00:44:17 - 00:00:52:00
Unknown
Since GitHub actions runners are stateless, we'll use an S3 bucket to store the state.

00:00:52:02 - 00:01:15:09
Unknown
Credentials. Next, we'll look at how to handle secrets. Our workflow needs AWS credentials to actually create resources. And we're not going to hardcode them. We're not that crazy. In your repo settings, add your AWS keys as encrypted secrets. GitHub actions will pull them as environment variables. When the workflow runs. In a real setup, you'd use short live credentials or an ODC set up instead of static keys.

00:01:15:09 - 00:01:39:12
Unknown
But for our demo, this is okay. Now onto the core of the process writing the GitHub actions workflow. Create a file and don't get lab slash workflows. Slash Terraform dot Yaml. We set it to run on pushes and pull requests to the main branch. We also configure environment variables in the workflow to load our AWS credentials, and a free bucket name from those secrets.

00:01:39:13 - 00:02:02:13
Unknown
Inside that workflow, it checks out the code, installs Terraform, runs Terraform init with our S3 backend settings, and links the code with Terraform fmt and Terraform validate on pull requests. It runs Terraform plan to show the proposed changes and post the plan output as a comment on the PR. Finally, when changes are merged into main, it runs Terraform apply to automatically deploy the changes.

00:02:02:14 - 00:02:27:24
Unknown
With this setup, every code change goes through a Terraform plan and if approved, a merged is applied without any one manually running. Terraform. It's not all sunshine and rainbows. GitHub actions. Plus Terraform can be great to get you moving fast until you hit team scale and governance. Here's some things to consider. State locking is non-negotiable. S3 remote state is necessary, but without proper locking.

00:02:27:24 - 00:02:57:13
Unknown
Often DynamoDB concurrent runs can collide. As soon as you have multiple paths you will fill. This credentials become a maintenance burden. Long live keys and secrets work, but now you own rotation, scoping and incident response. EDC is better, but it's still extra plumbing. You have to build across accounts and repos. Multi environment equals Yaml sprawl, dev staging. Prod means different variables, different backends, approvals and promotion roles.

00:02:57:15 - 00:03:22:09
Unknown
You either copy and paste workflows or build a mini deployment system in Yaml. Policy and governance is DIY. Now this is a big one. If you need to enforce tagging, block risky resources or require change windows. GitHub actions won't enforce that. By default, you end up stitching together checks and hoping they're applied consistently. It's a risky strategy. Drift detection won't happen by accident.

00:03:22:09 - 00:03:48:21
Unknown
If someone changes infrastructure outside of Terraform, actions won't tell you unless you build scheduled runs, reporting, and a safe remediation process. A more scalable alternative space, Lift Space Live takes a more scalable approach to terraform automation, with many of these safeguards built in, for example, state and credentials management space lifts doors securely and locks your Terraform state and can supply dynamic cloud credentials for runs.

00:03:48:22 - 00:04:13:04
Unknown
No need to set up S3 buckets, DynamoDB tables, or manage long lived keys yourself. Built in policy checks. Space lift also provides policy as code guardrails. You can set rules like no public S3 buckets, and space lift will automatically check Terraform plans against them, blocking anything that violates your policies. Drift detection the platform monitors your infrastructure for drift.

00:04:13:05 - 00:04:40:11
Unknown
If someone or something changes something outside of Terraform space, Lyft will flag it and can auto correct it too, ensuring your code and real infrastructure stay aligned. And finally, multi environment orchestration space Lyft handles multiple environments and stack dependencies gracefully. So to recap today we've looked at how to automate Terraform with GitHub actions from code in GitHub to automated plans and applies in CI.

00:04:40:11 - 00:04:55:10
Unknown
For more information, check out this blog post, also linked in the description. If you found this video helpful, please give us a thumbs up and subscribe for more DevOps and infrastructure as code content. Thank you so much for watching and happy automating! Face lift.

